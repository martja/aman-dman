<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/view/src/main/kotlin/no/vaccsca/amandman/view/tabpage/timeline/TimelineView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/view/src/main/kotlin/no/vaccsca/amandman/view/tabpage/timeline/TimelineView.kt" />
              <option name="originalContent" value="package no.vaccsca.amandman.view.tabpage.timeline&#10;&#10;import kotlinx.datetime.Instant&#10;import no.vaccsca.amandman.common.TimelineConfig&#10;import no.vaccsca.amandman.controller.ControllerInterface&#10;import no.vaccsca.amandman.model.dto.TimelineData&#10;import no.vaccsca.amandman.view.entity.TimeRange&#10;import no.vaccsca.amandman.view.util.SharedValue&#10;import java.awt.Dimension&#10;import java.awt.GridBagConstraints&#10;import java.awt.GridBagLayout&#10;import java.awt.Rectangle&#10;import javax.swing.JLayeredPane&#10;import javax.swing.JPanel&#10;import kotlin.time.Duration.Companion.seconds&#10;&#10;class TimelineView(&#10;    val timelineConfig: TimelineConfig,&#10;    private val selectedTimeRange: SharedValue&lt;TimeRange&gt;,&#10;    private val controllerInterface: ControllerInterface,&#10;) : JLayeredPane() {&#10;    private val basePanel = JPanel(GridBagLayout()) // Panel to hold components in a layout&#10;    private val labelContainer = TimelineOverlay(timelineConfig, this, controllerInterface)&#10;    private val isDual = timelineConfig.runwaysLeft.isNotEmpty() &amp;&amp; timelineConfig.runwaysRight.isNotEmpty()&#10;    private val timeScale = TimeScale(this, selectedTimeRange, !isDual, controllerInterface)&#10;&#10;    init {&#10;        layout = null // JLayeredPane requires explicit bounds for components&#10;        add(basePanel)&#10;        add(labelContainer)&#10;        setLayer(basePanel, DEFAULT_LAYER)&#10;        setLayer(labelContainer, PALETTE_LAYER)&#10;&#10;        val scaleWidth = 60&#10;        val listWidth = 280&#10;        val totalTimelineWidth =&#10;            if (isDual) scaleWidth + listWidth * 2&#10;            else scaleWidth + listWidth&#10;&#10;        preferredSize = Dimension(totalTimelineWidth, 0)&#10;&#10;        val gbc = GridBagConstraints()&#10;        gbc.fill = GridBagConstraints.BOTH // Allow full height expansion&#10;        gbc.weighty = 1.0 // Make components expand vertically&#10;&#10;        if (isDual) {&#10;            // Left TrafficSequenceView&#10;            gbc.gridx = 0&#10;            gbc.weightx = listWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(SequenceStack(this, TimelineAlignment.RIGHT), gbc)&#10;&#10;            // Scale visualisation&#10;            gbc.gridx = 1&#10;            gbc.weightx = scaleWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(timeScale, gbc)&#10;&#10;            // Right TrafficSequenceView&#10;            gbc.gridx = 2&#10;            gbc.weightx = listWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(SequenceStack(this, TimelineAlignment.LEFT), gbc)&#10;        } else {&#10;            // Scale visualisation&#10;            gbc.gridx = 0&#10;            gbc.weightx = scaleWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(timeScale, gbc)&#10;&#10;            // Single TrafficSequenceView&#10;            gbc.gridx = 1&#10;            gbc.weightx = listWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(SequenceStack(this, TimelineAlignment.RIGHT), gbc)&#10;        }&#10;&#10;        selectedTimeRange.addListener {&#10;            labelContainer.repaint()&#10;        }&#10;    }&#10;&#10;    fun updateTimelineData(timelineData: TimelineData) {&#10;        labelContainer.updateTimelineData(timelineData)&#10;        timeScale.updateTimelineData(timelineData)&#10;    }&#10;&#10;    fun calculateYPositionForInstant(instant: Instant): Int {&#10;        val timespanSeconds = selectedTimeRange.value.end.epochSeconds - selectedTimeRange.value.start.epochSeconds&#10;        val pixelsPerSecond = height.toFloat() / timespanSeconds.toFloat()&#10;        return (height - pixelsPerSecond * (instant.epochSeconds - selectedTimeRange.value.start.epochSeconds)).toInt()&#10;    }&#10;&#10;    fun calculateInstantForYPosition(y: Int): Instant {&#10;        val timespanSeconds = selectedTimeRange.value.end.epochSeconds - selectedTimeRange.value.start.epochSeconds&#10;        val pixelsPerSecond = height.toFloat() / timespanSeconds.toFloat()&#10;        val secondsFromStart = (height - y) / pixelsPerSecond&#10;        return selectedTimeRange.value.start + secondsFromStart.toLong().seconds&#10;    }&#10;&#10;    fun getScaleBounds(): Rectangle {&#10;        return timeScale.bounds&#10;    }&#10;&#10;    override fun doLayout() {&#10;        super.doLayout()&#10;        basePanel.setBounds(0, 0, width, height) // Resize base panel dynamically&#10;        labelContainer.setBounds(0, 0, width, height)&#10;    }&#10;&#10;    fun updateDraggedLabel(callsign: String, proposedTime: Instant, available: Boolean) {&#10;        labelContainer.updateDraggedLabel(callsign, proposedTime, available)&#10;    }&#10;}" />
              <option name="updatedContent" value="package no.vaccsca.amandman.view.tabpage.timeline&#10;&#10;import kotlinx.datetime.Instant&#10;import no.vaccsca.amandman.common.TimelineConfig&#10;import no.vaccsca.amandman.controller.ControllerInterface&#10;import no.vaccsca.amandman.model.dto.TimelineData&#10;import no.vaccsca.amandman.model.timelineEvent.RunwayArrivalEvent&#10;import no.vaccsca.amandman.view.entity.TimeRange&#10;import no.vaccsca.amandman.view.util.SharedValue&#10;import java.awt.Dimension&#10;import java.awt.GridBagConstraints&#10;import java.awt.GridBagLayout&#10;import java.awt.Rectangle&#10;import javax.swing.JLayeredPane&#10;import javax.swing.JPanel&#10;import kotlin.time.Duration.Companion.seconds&#10;&#10;class TimelineView(&#10;    val timelineConfig: TimelineConfig,&#10;    private val selectedTimeRange: SharedValue&lt;TimeRange&gt;,&#10;    private val controllerInterface: ControllerInterface,&#10;) : JLayeredPane() {&#10;    private val basePanel = JPanel(GridBagLayout()) // Panel to hold components in a layout&#10;    private val labelContainer = TimelineOverlay(timelineConfig, this, controllerInterface)&#10;    private val isDual = timelineConfig.runwaysLeft.isNotEmpty() &amp;&amp; timelineConfig.runwaysRight.isNotEmpty()&#10;    private val timeScale = TimeScale(this, selectedTimeRange, !isDual, controllerInterface)&#10;&#10;    init {&#10;        layout = null // JLayeredPane requires explicit bounds for components&#10;        add(basePanel)&#10;        add(labelContainer)&#10;        setLayer(basePanel, DEFAULT_LAYER)&#10;        setLayer(labelContainer, PALETTE_LAYER)&#10;&#10;        val scaleWidth = 60&#10;        val listWidth = 280&#10;        val totalTimelineWidth =&#10;            if (isDual) scaleWidth + listWidth * 2&#10;            else scaleWidth + listWidth&#10;&#10;        preferredSize = Dimension(totalTimelineWidth, 0)&#10;&#10;        val gbc = GridBagConstraints()&#10;        gbc.fill = GridBagConstraints.BOTH // Allow full height expansion&#10;        gbc.weighty = 1.0 // Make components expand vertically&#10;&#10;        if (isDual) {&#10;            // Left TrafficSequenceView&#10;            gbc.gridx = 0&#10;            gbc.weightx = listWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(SequenceStack(this, TimelineAlignment.RIGHT), gbc)&#10;&#10;            // Scale visualisation&#10;            gbc.gridx = 1&#10;            gbc.weightx = scaleWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(timeScale, gbc)&#10;&#10;            // Right TrafficSequenceView&#10;            gbc.gridx = 2&#10;            gbc.weightx = listWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(SequenceStack(this, TimelineAlignment.LEFT), gbc)&#10;        } else {&#10;            // Scale visualisation&#10;            gbc.gridx = 0&#10;            gbc.weightx = scaleWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(timeScale, gbc)&#10;&#10;            // Single TrafficSequenceView&#10;            gbc.gridx = 1&#10;            gbc.weightx = listWidth / totalTimelineWidth.toDouble()&#10;            basePanel.add(SequenceStack(this, TimelineAlignment.RIGHT), gbc)&#10;        }&#10;&#10;        selectedTimeRange.addListener {&#10;            labelContainer.repaint()&#10;        }&#10;    }&#10;&#10;    fun updateTimelineData(timelineData: TimelineData) {&#10;        labelContainer.updateTimelineData(timelineData)&#10;        timeScale.updateTimelineData(timelineData)&#10;    }&#10;&#10;    fun calculateYPositionForInstant(instant: Instant): Int {&#10;        val timespanSeconds = selectedTimeRange.value.end.epochSeconds - selectedTimeRange.value.start.epochSeconds&#10;        val pixelsPerSecond = height.toFloat() / timespanSeconds.toFloat()&#10;        return (height - pixelsPerSecond * (instant.epochSeconds - selectedTimeRange.value.start.epochSeconds)).toInt()&#10;    }&#10;&#10;    fun calculateInstantForYPosition(y: Int): Instant {&#10;        val timespanSeconds = selectedTimeRange.value.end.epochSeconds - selectedTimeRange.value.start.epochSeconds&#10;        val pixelsPerSecond = height.toFloat() / timespanSeconds.toFloat()&#10;        val secondsFromStart = (height - y) / pixelsPerSecond&#10;        return selectedTimeRange.value.start + secondsFromStart.toLong().seconds&#10;    }&#10;&#10;    fun getScaleBounds(): Rectangle {&#10;        return timeScale.bounds&#10;    }&#10;&#10;    override fun doLayout() {&#10;        super.doLayout()&#10;        basePanel.setBounds(0, 0, width, height) // Resize base panel dynamically&#10;        labelContainer.setBounds(0, 0, width, height)&#10;    }&#10;&#10;    fun updateDraggedLabel(callsign: String, proposedTime: Instant, available: Boolean) {&#10;        labelContainer.updateDraggedLabel(callsign, proposedTime, available)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>